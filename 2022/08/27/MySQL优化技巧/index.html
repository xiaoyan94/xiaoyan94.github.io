<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-169911533-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-169911533-1');
</script>

  

  
  <title>MySQL优化技巧 | 空城盼故人</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="google-site-verification" content="NOVpqBhVVjZHOamocUf3Grijt7xAK_Engoe_FNrxE3Q" />
  <meta name="baidu-site-verification" content="HBrapLOndy" />
  
  <meta property="og:type" content="article">
<meta property="og:title" content="MySQL优化技巧">
<meta property="og:url" content="https://xiaoyan94.github.io/2022/08/27/MySQL%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="空城盼故人">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaoyan94.github.io/images/bg.jpg">
<meta property="og:image" content="https://s1.51cto.com/oss/202008/19/734e0d75c12e4026751e71dd2d7b0812.png">
<meta property="article:published_time" content="2022-08-27T05:56:46.000Z">
<meta property="article:modified_time" content="2022-08-27T07:05:55.509Z">
<meta property="article:author" content="许嵩老公">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="转载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaoyan94.github.io/images/bg.jpg">
  
    <link rel="alternate" href="../../../../atom.xml" title="空城盼故人" type="application/atom+xml">
  
  
    <link rel="icon" href="https://q1.qlogo.cn/g?b=qq&nk=979727728&s=640">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="../../../../css/style.css">

  
<link rel="stylesheet" href="../../../../css/highlight.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="fullpage" class="mobile-nav-right">
    <div class="fixed"></div>
    
      <div id="wrapper">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="../../../../index.html" title
        
        >首页</a>
      
        <a class="nav-item" href="../../../../archives" title
        
        >归档</a>
      
        <a class="nav-item" href="../../../../quick-notes" title
        
        >小抄</a>
      
        <a class="nav-item" href="../../../../about" title
        
        >关于</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main"><article id="post-MySQL优化技巧" class="article global-container article-type-post" itemscope itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 class="article-title" itemprop="name">
      MySQL优化技巧
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="" class="article-date">
  <time datetime="2022-08-27T05:56:46.000Z" itemprop="datePublished">2022-08-27</time>
</a>
    
    
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/SQL/" rel="tag">SQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

  </div>
  
    <span id="busuanzi_container_page_pv">
      本文总阅读量<span id="busuanzi_value_page_pv"></span>次
    </span>
  

  <div class="article-inner">
    
    <div class="article-content article-content-cloud" itemprop="articleBody">
      
        
        <p><img src="/images/bg.jpg" alt="SQL优化"></p>
<a id="more"></a>

<p>SQL 优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，如果是你，在这个问题上能吊打面试官还是会被吊打呢？</p>
<p>有朋友疑问到，SQL 优化真的有这么重要么？如下图所示，SQL 优化在提升系统性能中是：成本最低和优化效果最明显的途径。</p>
<p>如果你的团队在 SQL 优化这方面搞得很优秀，对你们整个大型系统可用性方面无疑是一个质的跨越，真的能让你们老板省下不止几沓子钱。</p>
<p><img src="https://s1.51cto.com/oss/202008/19/734e0d75c12e4026751e71dd2d7b0812.png" alt="2"></p>
<p><strong>优化成本：</strong> 硬件&gt;系统配置&gt;数据库表结构&gt;SQL 及索引。</p>
<p><strong>优化效果：</strong> 硬件&lt;系统配置&lt;数据库表结构&lt;SQL 及索引。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">"嗯，不错，"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"SQL 优化经验足"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"熟悉事务锁"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"并发场景处理 666"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"会打王者荣耀"</span>) &#123;</span><br><span class="line">                result += <span class="string">"明天入职"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result += <span class="string">"先回去等消息吧"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Logger.info (<span class="string">"面试官："</span> + result );</span><br></pre></td></tr></table></figure></div>

<p>别看了，上面这是一道送命题。</p>
<p>好了我们言归正传，首先，对于 MySQL 层优化我一般遵从五个原则：</p>
<ul>
<li><p><strong>减少数据访问：</strong> 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘 IO。</p>
</li>
<li><p><strong>返回更少的数据：</strong> 只返回需要的字段和数据分页处理，减少磁盘 IO 及网络 IO。</p>
</li>
<li><p><strong>减少交互次数：</strong> 批量 DML 操作，函数存储等减少数据连接次数。</p>
</li>
<li><p><strong>减少服务器 CPU 开销：</strong> 尽量减少数据库排序操作以及全表查询，减少 CPU 内存占用。</p>
</li>
<li><p><strong>利用更多资源：</strong> 使用表分区，可以增加并行操作，更大限度利用 CPU 资源。</p>
</li>
</ul>
<p>总结到 SQL 优化中，就如下三点：</p>
<ul>
<li><p><strong>最大化利用索引。</strong></p>
</li>
<li><p><strong>尽可能避免全表扫描。</strong></p>
</li>
<li><p><strong>减少无效数据的查询。</strong></p>
</li>
</ul>
<p>理解 SQL 优化原理 ，首先要搞清楚 SQL 执行顺序。</p>
<h2 id="SELECT-语句，语法顺序如下"><a href="#SELECT-语句，语法顺序如下" class="headerlink" title="SELECT 语句，语法顺序如下"></a>SELECT 语句，语法顺序如下</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">DISTINCT</span> &lt; select_list &gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  &lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line">  <span class="keyword">JOIN</span> &lt; right_table &gt; <span class="keyword">ON</span> &lt; join_condition &gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  &lt; where_condition &gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  &lt; group_by_list &gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">  &lt; having_condition &gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  &lt; order_by_condition &gt;</span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">  &lt; limit_number &gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="SELECT-语句，执行顺序如下"><a href="#SELECT-语句，执行顺序如下" class="headerlink" title="SELECT 语句，执行顺序如下"></a>SELECT 语句，执行顺序如下</h2><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM</span><br><span class="line">&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。</span><br><span class="line">ON</span><br><span class="line">&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选</span><br><span class="line">JOIN &lt;join, left join, right join...&gt;</span><br><span class="line">&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中</span><br><span class="line">WHERE</span><br><span class="line">&lt;where条件&gt; # 对上述虚表进行筛选</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;分组条件&gt; # 分组</span><br><span class="line">&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的</span><br><span class="line">HAVING</span><br><span class="line">&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">&lt;返回数据列表&gt; <span class="comment"># 返回的单列必须在group by子句中，聚合函数除外</span></span><br><span class="line"><span class="keyword">DISTINCT</span></span><br><span class="line"><span class="comment"># 数据除重</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">&lt;排序条件&gt; <span class="comment"># 排序</span></span><br><span class="line"><span class="keyword">LIMIT</span></span><br><span class="line">&lt;行数限制&gt;</span><br></pre></td></tr></table></figure></div>

<p>以下 SQL 优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足</p>
<h3 id="避免不走索引的场景"><a href="#避免不走索引的场景" class="headerlink" title="避免不走索引的场景"></a>避免不走索引的场景</h3><h4 id="①-尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描"><a href="#①-尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描" class="headerlink" title="① 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描"></a>① <strong>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描</strong></h4><p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">'%陈%'</span></span><br></pre></td></tr></table></figure></div>

<p><strong>优化方式：</strong> 尽量在字段 <strong>后面</strong> 使用模糊查询。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> username <span class="keyword">LIKE</span> <span class="string">'陈%'</span></span><br></pre></td></tr></table></figure></div>

<p>如果需求是要在前面使用模糊查询：</p>
<ul>
<li><p>使用 MySQL 内置函数 INSTR（str，substr）来匹配，作用类似于 Java 中的 indexOf()，查询字符串出现的角标位置。</p>
</li>
<li><p>使用 FullText 全文索引，用 match against 检索。</p>
</li>
<li><p>数据量较大的情况，建议引用 ElasticSearch、Solr，亿级数据量检索速度秒级。</p>
</li>
<li><p>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用 like ‘%xx%’。</p>
</li>
</ul>
<h4 id="②-尽量避免使用-in-和-not-in，会导致引擎走全表扫描"><a href="#②-尽量避免使用-in-和-not-in，会导致引擎走全表扫描" class="headerlink" title="② 尽量避免使用 in 和 not in，会导致引擎走全表扫描"></a>② <strong>尽量避免使用 in 和 not in，会导致引擎走全表扫描</strong></h4><p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>优化方式：</strong> 如果是连续数值，可以用 <code>between</code> 代替。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p>如果是子查询，可以用 <code>exists</code> 代替。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走索引</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  A</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  A.id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="keyword">id</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      B</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  A</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      *</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      B</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      B.id = A.id</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></div>

<h4 id="③-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描"><a href="#③-尽量避免使用-or，会导致数据库引擎放弃索引进行全表扫描" class="headerlink" title="③ 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描"></a>③ <strong>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描</strong></h4><p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">OR</span> <span class="keyword">id</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<p><strong>优化方式：</strong> 可以用 union 代替 or。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">id</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">id</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<h4 id="④-尽量避免进行-null-值的判断，会导致数据库引擎放弃索引进行全表扫描"><a href="#④-尽量避免进行-null-值的判断，会导致数据库引擎放弃索引进行全表扫描" class="headerlink" title="④ 尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描"></a>④ <strong>尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描</strong></h4><p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></div>

<p><strong>优化方式：</strong> 可以给字段添加默认值 0，对 0 值进行判断。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> score = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h4 id="⑤-尽量避免在-where-条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描"><a href="#⑤-尽量避免在-where-条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描" class="headerlink" title="⑤ 尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描"></a>⑤ <strong>尽量避免在 where 条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描</strong></h4><p>可以将表达式、函数操作移动到等号右侧，如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全表扫描</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score/<span class="number">10</span> = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> score = <span class="number">10</span>*<span class="number">9</span></span><br></pre></td></tr></table></figure></div>

<h4 id="⑥-当数据量大时，避免使用-where-1-1-的条件"><a href="#⑥-当数据量大时，避免使用-where-1-1-的条件" class="headerlink" title="⑥ 当数据量大时，避免使用 where 1=1 的条件"></a>⑥ <strong>当数据量大时，避免使用 where 1=1 的条件</strong></h4><p>通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。</p>
<p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, age, sex <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><strong>优化方式：</strong> 用代码拼装 SQL 时进行判断，没 where 条件就去掉 where，有 where 条件就加 and。</p>
<h4 id="⑦-查询条件不能用-lt-gt-或者"><a href="#⑦-查询条件不能用-lt-gt-或者" class="headerlink" title="⑦ 查询条件不能用 &lt;&gt; 或者 !="></a>⑦ <strong>查询条件不能用 &lt;&gt; 或者 !=</strong></h4><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。</p>
<p>如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p>
<h4 id="⑧-where-条件仅包含复合索引非前置列"><a href="#⑧-where-条件仅包含复合索引非前置列" class="headerlink" title="⑧ where 条件仅包含复合索引非前置列"></a>⑧ <strong>where 条件仅包含复合索引非前置列</strong></h4><p>如下：复合（联合）索引包含 key_part1，key_part2，key_part3 三列，但 SQL 语句没有包含索引前置列”key_part1”，按照 MySQL 联合索引的最左匹配原则，不会走联合索引。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> key_part2=<span class="number">1</span> <span class="keyword">and</span> key_part3=<span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<h4 id="⑨-隐式类型转换造成不使用索引"><a href="#⑨-隐式类型转换造成不使用索引" class="headerlink" title="⑨ 隐式类型转换造成不使用索引"></a>⑨ <strong>隐式类型转换造成不使用索引</strong></h4><p>如下 SQL 语句由于索引对列类型为 varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col_varchar=<span class="number">123</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="⑩-order-by-条件要与-where-中条件一致，否则-order-by-不会利用索引进行排序"><a href="#⑩-order-by-条件要与-where-中条件一致，否则-order-by-不会利用索引进行排序" class="headerlink" title="⑩ order by 条件要与 where 中条件一致，否则 order by 不会利用索引进行排序"></a>⑩ <strong>order by 条件要与 where 中条件一致，否则 order by 不会利用索引进行排序</strong></h4><p>如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不走age索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 走age索引</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">where</span> age &gt; <span class="number">0</span> <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure></div>

<p>对于上面的语句，数据库的处理顺序是：</p>
<ul>
<li><p><strong>第一步：</strong> 根据 where 条件和统计信息生成执行计划，得到数据。</p>
</li>
<li><p><strong>第二步：</strong> 将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看 order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。</p>
</li>
<li><p><strong>第三步：</strong> 返回排序后的数据。</p>
</li>
</ul>
<p>当 order by 中的字段出现在 where 条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。</p>
<p>这个结论不仅对 order by 有效，对其他需要排序的操作也有效。比如 group by 、union 、distinct 等。</p>
<h4 id="⑪-正确使用-hint-优化语句"><a href="#⑪-正确使用-hint-优化语句" class="headerlink" title="⑪ 正确使用 hint 优化语句"></a>⑪ <strong>正确使用 hint 优化语句</strong></h4><p>MySQL 中可以使用 hint 指定优化器在执行时选择或忽略特定的索引。</p>
<p>一般而言，处于版本变更带来的表结构索引变化，更建议避免使用 hint，而是通过 Analyze table 多收集统计信息。</p>
<p>但在特定场合下，指定 hint 可以排除其他索引干扰而指定更优的执行计划：</p>
<ul>
<li><p>USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。</p>
<p>例子: <code>SELECT col1 FROM table USE INDEX (mod_time, name)...</code></p>
</li>
<li><p>IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。</p>
<p>例子: <code>SELECT col1 FROM table IGNORE INDEX (priority) ...</code></p>
</li>
<li><p>FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 Hint。</p>
<p>例子: <code>SELECT col1 FROM table FORCE INDEX (mod_time) ...</code></p>
</li>
</ul>
<p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。</p>
<p>如果我们知道如何选择索引，可以使用 FORCE INDEX 强制查询使用指定的索引。</p>
<p>例如：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  students <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> (idx_class_id)</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  class_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">id</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="SELECT-语句其他优化"><a href="#SELECT-语句其他优化" class="headerlink" title="SELECT 语句其他优化"></a>SELECT 语句其他优化</h3><h4 id="①-避免出现-select"><a href="#①-避免出现-select" class="headerlink" title="① 避免出现 select *"></a>① <strong>避免出现 select *</strong></h4><p>首先，select * 操作在任何类型数据库中都不是一个好的 SQL 编写习惯。</p>
<p>使用 select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的 I/O，内存和 CPU 消耗。</p>
<p>建议提出业务实际需要的列数，将指定列名以取代 select *。具体详情见<a href="http://mp.weixin.qq.com/s?__biz=MzU5NDgyMjc0OQ==&mid=2247489808&idx=3&sn=a12f311695bf33c60e09fe8a85c50081&chksm=fe7a0a22c90d8334347c27d72a54da2aa36308bed2f39347467aee56e680fb09087f92a78178&scene=21#wechat_redirect" target="_blank" rel="noopener">为什么大家都说 SELECT * 效率低</a></p>
<h4 id="②-避免出现不确定结果的函数"><a href="#②-避免出现不确定结果的函数" class="headerlink" title="② 避免出现不确定结果的函数"></a>② <strong>避免出现不确定结果的函数</strong></h4><p>特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如 now()、rand()、sysdate()、current_user() 等不确定结果的函数很容易导致主库与从库相应的数据不一致。</p>
<p>另外不确定值的函数，产生的 SQL 语句无法利用 query cache。</p>
<h4 id="③-多表关联查询时，小表在前，大表在后"><a href="#③-多表关联查询时，小表在前，大表在后" class="headerlink" title="③ 多表关联查询时，小表在前，大表在后"></a>③ <strong>多表关联查询时，小表在前，大表在后</strong></h4><p>在 MySQL 中，执行 from 后的表关联查询是从左往右执行的（Oracle 相反），第一张表会涉及到全表扫描。</p>
<p>所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前 100 行就符合返回条件并 return 了。</p>
<p>例如：表 1 有 50 条数据，表 2 有 30 亿条数据；如果全表扫描表 2，你品，那就先去吃个饭再说吧是吧。</p>
<h4 id="④-使用表的别名"><a href="#④-使用表的别名" class="headerlink" title="④ 使用表的别名"></a>④ <strong>使用表的别名</strong></h4><p>当在 SQL 语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。</p>
<h4 id="⑤-用-where-字句替换-HAVING-字句"><a href="#⑤-用-where-字句替换-HAVING-字句" class="headerlink" title="⑤ 用 where 字句替换 HAVING 字句"></a>⑤ <strong>用 where 字句替换 HAVING 字句</strong></h4><p>避免使用 HAVING 字句，因为 HAVING 只会在检索出所有记录之后才对结果集进行过滤，而 where 则是在聚合前刷选记录，如果能通过 where 字句限制记录的数目，那就能减少这方面的开销。</p>
<p>HAVING 中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在 where 字句中。</p>
<p>where 和 having 的区别：where 后面不能使用组函数。</p>
<h4 id="⑥-调整-Where-字句中的连接顺序"><a href="#⑥-调整-Where-字句中的连接顺序" class="headerlink" title="⑥ 调整 Where 字句中的连接顺序"></a>⑥ <strong>调整 Where 字句中的连接顺序</strong></h4><p>MySQL 采用从左往右，自上而下的顺序解析 where 子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</p>
<h3 id="增删改-DML-语句优化"><a href="#增删改-DML-语句优化" class="headerlink" title="增删改 DML 语句优化"></a>增删改 DML 语句优化</h3><h4 id="①-大批量插入数据"><a href="#①-大批量插入数据" class="headerlink" title="① 大批量插入数据"></a>① <strong>大批量插入数据</strong></h4><p>如果同时执行大量的插入，建议使用多个值的 INSERT 语句（方法二）。这比使用分开 INSERT 语句快（方法一），一般情况下批量插入效率有几倍的差别。</p>
<p>方法一：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  T</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  T</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span></span><br><span class="line">  T</span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></div>

<p>方法二：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></div>

<p>选择后一种方法的原因有三：</p>
<ul>
<li><p>减少 SQL 语句解析的操作，MySQL 没有类似 Oracle 的 share pool，采用方法二，只需要解析一次就能进行数据的插入操作。</p>
</li>
<li><p>在特定场景可以减少对 DB 连接次数。</p>
</li>
<li><p>SQL 语句较短，可以减少网络传输的 IO。</p>
</li>
</ul>
<h4 id="②-适当使用-commit"><a href="#②-适当使用-commit" class="headerlink" title="② 适当使用 commit"></a>② <strong>适当使用 commit</strong></h4><p>适当使用 commit 可以释放事务占用的资源而减少消耗，commit 后能释放的资源如下：</p>
<ul>
<li><p>事务占用的 undo 数据块。</p>
</li>
<li><p>事务在 redo log 中记录的数据块。</p>
</li>
<li><p>释放事务施加的，减少锁争用影响性能。特别是在需要使用 delete 删除大量数据的时候，必须分解删除量并定期 commit。</p>
</li>
</ul>
<h4 id="③-避免重复查询更新的数据"><a href="#③-避免重复查询更新的数据" class="headerlink" title="③ 避免重复查询更新的数据"></a>③ <strong>避免重复查询更新的数据</strong></h4><p>针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL 并不支持 PostgreSQL 那样的 UPDATE RETURNING 语法，在 MySQL 中可以通过变量实现。</p>
<p>例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么？</p>
<p>简单方法实现：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Update</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="keyword">now</span>()</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  col1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span></span><br><span class="line">  <span class="built_in">time</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>使用变量，可以重写为以下方式：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Update</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  <span class="built_in">time</span> = <span class="keyword">now</span> ()</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  col1 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">and</span> @ <span class="keyword">now</span>: = <span class="keyword">now</span> ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span></span><br><span class="line">  @ <span class="keyword">now</span>;</span><br></pre></td></tr></table></figure></div>

<p>前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当 t1 表数据量较大时，后者比前者快很多。</p>
<h4 id="④-查询优先还是更新（insert、update、delete）优先"><a href="#④-查询优先还是更新（insert、update、delete）优先" class="headerlink" title="④ 查询优先还是更新（insert、update、delete）优先"></a>④ <strong>查询优先还是更新（insert、update、delete）优先</strong></h4><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。</p>
<p>我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。</p>
<p>下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如  MyISAM 、MEMROY、MERGE，对于 Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。</p>
<p>MySQL 的默认的调度策略可用总结如下：</p>
<ul>
<li><p>写入操作优先于读取操作。</p>
</li>
<li><p>对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p>
</li>
<li><p>对某张数据表的多个读取操作可以同时地进行。</p>
</li>
</ul>
<p>MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p>
<ul>
<li><p>LOW_PRIORITY 关键字应用于 DELETE、INSERT、LOAD DATA、REPLACE 和 UPDATE。</p>
</li>
<li><p>HIGH_PRIORITY 关键字应用于 SELECT 和 INSERT 语句。</p>
</li>
<li><p>DELAYED 关键字应用于 INSERT 和 REPLACE 语句。</p>
</li>
</ul>
<p>如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。</p>
<p>在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。</p>
<p>只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY 写入操作永远被阻塞的情况。</p>
<p>SELECT 查询的 HIGH_PRIORITY（高优先级）关键字也类似。它允许 SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。</p>
<p>另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。</p>
<p>如果希望所有支持 LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么请使用–low-priority-updates 选项来启动服务器。</p>
<p>通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个 INSERT 语句的影响。</p>
<h3 id="查询条件优化"><a href="#查询条件优化" class="headerlink" title="查询条件优化"></a>查询条件优化</h3><h4 id="①-对于复杂的查询，可以使用中间临时表暂存数据"><a href="#①-对于复杂的查询，可以使用中间临时表暂存数据" class="headerlink" title="① 对于复杂的查询，可以使用中间临时表暂存数据"></a>① <strong>对于复杂的查询，可以使用中间临时表暂存数据</strong></h4><h4 id="②-优化-group-by-语句"><a href="#②-优化-group-by-语句" class="headerlink" title="② 优化 group by 语句"></a>② <strong>优化 group by 语句</strong></h4><p>默认情况下，MySQL 会对 GROUP BY 分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 。</p>
<p>如果显式包括一个包含相同的列的 ORDER BY 子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p>
<p>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL 禁止排序。</p>
<p>例如：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  col1,</span><br><span class="line">  col2,</span><br><span class="line">  <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">table</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  col1,</span><br><span class="line">  col2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="③-优化-join-语句"><a href="#③-优化-join-语句" class="headerlink" title="③ 优化 join 语句"></a>③ <strong>优化 join 语句</strong></h4><p>MySQL 中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。</p>
<p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）..替代。</p>
<p>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  col1</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  customerinfo</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  CustomerID <span class="keyword">NOT</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      CustomerID</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      salesinfo</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></div>

<p>如果使用连接（JOIN）..来完成这个查询工作，速度将会有所提升。</p>
<p>尤其是当 salesinfo 表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  col1</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  customerinfo</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> salesinfoON customerinfo.CustomerID = salesinfo.CustomerID</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  salesinfo.CustomerID <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></div>

<p>连接（JOIN）..之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p>
<h4 id="④-优化-union-查询"><a href="#④-优化-union-查询" class="headerlink" title="④ 优化 union 查询"></a>④ <strong>优化 union 查询</strong></h4><p>MySQL 通过创建并填充临时表的方式来执行 union 查询。除非确实要消除重复的行，否则建议使用 union all。</p>
<p>原因在于如果没有 all 这个关键词，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。</p>
<p>高效：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  COL1,</span><br><span class="line">  COL2,</span><br><span class="line">  COL3</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  COL1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  COL1,</span><br><span class="line">  COL2,</span><br><span class="line">  COL3</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  COL3 = <span class="string">'TEST'</span>;</span><br></pre></td></tr></table></figure></div>

<p>低效：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  COL1,</span><br><span class="line">  COL2,</span><br><span class="line">  COL3</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  COL1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  COL1,</span><br><span class="line">  COL2,</span><br><span class="line">  COL3</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  COL3 = <span class="string">'TEST'</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="⑤-拆分复杂-SQL-为多个小-SQL，避免大事务"><a href="#⑤-拆分复杂-SQL-为多个小-SQL，避免大事务" class="headerlink" title="⑤ 拆分复杂 SQL 为多个小 SQL，避免大事务"></a>⑤ <strong>拆分复杂 SQL 为多个小 SQL，避免大事务</strong></h4><p>如下：</p>
<ul>
<li><p>简单的 SQL 容易使用到 MySQL 的 QUERY CACHE。</p>
</li>
<li><p>减少锁表时间特别是使用 MyISAM 存储引擎的表。</p>
</li>
<li><p>可以使用多核 CPU。</p>
</li>
</ul>
<h4 id="⑥-使用-truncate-代替-delete"><a href="#⑥-使用-truncate-代替-delete" class="headerlink" title="⑥ 使用 truncate 代替 delete"></a>⑥ <strong>使用 truncate 代替 delete</strong></h4><p>当删除全表中记录时，使用 delete 语句的操作会被记录到 undo 块中，删除记录也记录 binlog。</p>
<p>当确认需要删除全表时，会产生很大量的 binlog 并占用大量的 undo 数据块，此时既没有很好的效率也占用了大量的资源。</p>
<p>使用 truncate 替代，不会记录可恢复的信息，数据不能被恢复。也因此使用 truncate 操作有其极少的资源占用与极快的时间。另外，使用 truncate 可以回收表的水位，使自增字段值归零。</p>
<h4 id="⑦-使用合理的分页方式以提高分页效率"><a href="#⑦-使用合理的分页方式以提高分页效率" class="headerlink" title="⑦ 使用合理的分页方式以提高分页效率"></a>⑦ <strong>使用合理的分页方式以提高分页效率</strong></h4><p>使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。</p>
<p>案例 1：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  thread_id = <span class="number">10000</span></span><br><span class="line">  <span class="keyword">and</span> deleted = <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">  gmt_create <span class="keyword">asc</span></span><br><span class="line"><span class="keyword">limit</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">15</span>;</span><br></pre></td></tr></table></figure></div>

<p>上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引 IO+索引全部记录结果对应的表数据 IO。</p>
<p>因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。</p>
<p>适用场景：当中间结果集很小（10000 行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。</p>
<p>案例 2：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  t.*</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="keyword">id</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      t</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      thread_id = <span class="number">10000</span></span><br><span class="line">      <span class="keyword">and</span> deleted = <span class="number">0</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      gmt_create <span class="keyword">asc</span></span><br><span class="line">    <span class="keyword">limit</span></span><br><span class="line">      <span class="number">0</span>, <span class="number">15</span></span><br><span class="line">  ) a,</span><br><span class="line">  t</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  a.id = t.id;</span><br></pre></td></tr></table></figure></div>

<p>上述例子必须满足 t 表主键是 id 列，且有覆盖索引 secondary key：（thread_id, deleted, gmt_create）。</p>
<p>通过先根据过滤条件利用覆盖索引取出主键 id 进行排序，再进行 join 操作取出其他字段。</p>
<p>数据访问开销=索引 IO+索引分页后结果（例子中是 15 行）对应的表数据 IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。</p>
<p><strong>适用场景：</strong> 当查询和排序字段（即 where 子句和 order by 子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。</p>
<h3 id="建表优化"><a href="#建表优化" class="headerlink" title="建表优化"></a>建表优化</h3><p>① <strong>在表中建立索引，优先考虑 where、order by 使用到的字段。</strong></p>
<p>② <strong>尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。</strong></p>
<p>这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>③ <strong>查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。</strong></p>
<p>要查询 100000 到 100050 的数据，如下：</p>
<div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      ROW_NUMBER() <span class="keyword">OVER</span>(</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">          <span class="keyword">ID</span> <span class="keyword">ASC</span></span><br><span class="line">      ) <span class="keyword">rowid</span>,</span><br><span class="line">      *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      infoTab</span><br><span class="line">  ) t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  t.rowid &gt; <span class="number">100000</span></span><br><span class="line">  <span class="keyword">AND</span> t.rowid &lt;= <span class="number">100050</span></span><br></pre></td></tr></table></figure></div>

<p>④ <strong>用 varchar/nvarchar 代替 char/nchar。</strong></p>
<p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL 也包含在内），都是占用 100 个字符的空间的，如果是 varchar 这样的变长字段， null 不占用空间。</p>
<p>_作者：<em>\</em>陈哈哈</p>
<p><em>出处：<a href="https://sohu.gg/FGG98i" target="_blank" rel="noopener">https://sohu.gg/FGG98i</a></em></p>

          
      
    </div>
    
    
      <footer class="article-footer">
        完
      </footer>
    
  </div>
  
    
<nav id="article-nav">
  <div class="article-nav-block">
    
      <a href="../%E7%94%B5%E8%84%91BIOS%E7%83%AD%E9%94%AEU%E7%9B%98%E5%90%AF%E5%8A%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%A1%A8/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption"></strong>
        <div class="article-nav-title">
          
            电脑BIOS热键U盘启动快捷键表
          
        </div>
      </a>
    
  </div>
  <div class="article-nav-block">
    
      <a href="../SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
        <div class="article-nav-title">SQL学习笔记</div>
        <strong class="article-nav-caption"></strong>
      </a>
    
  </div>
</nav>

    <!-- <link rel="stylesheet" href="/css/gitment.css">  -->
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<div id="vcommentsContainer"></div>
<!--引用评论框输入特效js文件-->

<script src="../../../../js/shuru.js"></script>

<script>
  POWERMODE.colorful = true; // make power mode colorful
  POWERMODE.shake = true; // turn off shake
  document.body.addEventListener('input', POWERMODE);
</script>
<!-- valine评论系统 -->
<script>
  new Valine({
      el: '#vcommentsContainer',
      appId: 'AttjBiS7UwxkxjV1CSrNywoi-gzGzoHsz',
      appKey: 'F50aWycFFmAPLC8CfSW7rXdP',
      avatar: 'monsterid',
      enableQQ: true,
      placeholder: '昵称处填QQ号自动抓取网名和邮箱哟~'
  })
</script>


    <!-- <link rel="stylesheet" href="/css/gitment.css"> 
<script src="/js/gitment.js"></script>

<div id="gitmentContainer"></div>

<script>
var gitment = new Gitment({
  owner: '',
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  },
})
gitment.render('gitmentContainer')
</script>

 -->

  
  
</article>
</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="https://q1.qlogo.cn/g?b=qq&amp;nk=979727728&amp;s=640" title="图片来自QQ"></img>
    <h3 class="avatar-name">
      
        许嵩老公
      
    </h3>
    <p class="avatar-slogan">
      深吸一口梦，吹个气球存起来。
    </p>
  </div>
</div>


  
    

  
    
  <div class="widget-box">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Git-Bash/" rel="tag">Git Bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Github-Actions/" rel="tag">Github Actions</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/HDFS/" rel="tag">HDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Hadoop/" rel="tag">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Idea/" rel="tag">Idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/MapReduce/" rel="tag">MapReduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/VSCode/" rel="tag">VSCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/YARN/" rel="tag">YARN</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/macOS/" rel="tag">macOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/ssh/" rel="tag">ssh</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/" rel="tag">中文乱码</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" rel="tag">安装教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E5%AF%86%E9%92%A5/" rel="tag">密钥</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E7%94%B5%E8%84%91/" rel="tag">电脑</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E7%AB%B9%E4%BA%91/" rel="tag">竹云</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E7%BB%88%E7%AB%AF/" rel="tag">终端</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E8%8B%B1%E8%AF%AD/" rel="tag">英语</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li><li class="tag-list-item"><a class="tag-list-link" href="../../../../tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="../../../../tags/Git-Bash/" style="font-size: 10px;">Git Bash</a> <a href="../../../../tags/Github/" style="font-size: 14px;">Github</a> <a href="../../../../tags/Github-Actions/" style="font-size: 10px;">Github Actions</a> <a href="../../../../tags/HDFS/" style="font-size: 10px;">HDFS</a> <a href="../../../../tags/Hadoop/" style="font-size: 18px;">Hadoop</a> <a href="../../../../tags/Idea/" style="font-size: 10px;">Idea</a> <a href="../../../../tags/JVM/" style="font-size: 18px;">JVM</a> <a href="../../../../tags/Java/" style="font-size: 20px;">Java</a> <a href="../../../../tags/Linux/" style="font-size: 16px;">Linux</a> <a href="../../../../tags/MapReduce/" style="font-size: 12px;">MapReduce</a> <a href="../../../../tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="../../../../tags/Maven/" style="font-size: 14px;">Maven</a> <a href="../../../../tags/SQL/" style="font-size: 14px;">SQL</a> <a href="../../../../tags/Shell/" style="font-size: 12px;">Shell</a> <a href="../../../../tags/VSCode/" style="font-size: 10px;">VSCode</a> <a href="../../../../tags/YARN/" style="font-size: 10px;">YARN</a> <a href="../../../../tags/hexo/" style="font-size: 12px;">hexo</a> <a href="../../../../tags/macOS/" style="font-size: 12px;">macOS</a> <a href="../../../../tags/ssh/" style="font-size: 12px;">ssh</a> <a href="../../../../tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/" style="font-size: 10px;">中文乱码</a> <a href="../../../../tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="../../../../tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" style="font-size: 10px;">安装教程</a> <a href="../../../../tags/%E5%AF%86%E9%92%A5/" style="font-size: 10px;">密钥</a> <a href="../../../../tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="../../../../tags/%E7%94%B5%E8%84%91/" style="font-size: 10px;">电脑</a> <a href="../../../../tags/%E7%AB%B9%E4%BA%91/" style="font-size: 12px;">竹云</a> <a href="../../../../tags/%E7%BB%88%E7%AB%AF/" style="font-size: 12px;">终端</a> <a href="../../../../tags/%E8%8B%B1%E8%AF%AD/" style="font-size: 10px;">英语</a> <a href="../../../../tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 10px;">转载</a> <a href="../../../../tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="../../../../archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="../../29/NET-Framework-%E8%BF%9E%E6%8E%A5-Oracle%E6%95%B0%E6%8D%AE%E5%BA%93/">.NET Framework 连接 Oracle数据库：找不到请求的 .Net Framework Data Provider。可能没有安装</a>
          </li>
        
          <li>
            <a href="../%E7%94%B5%E8%84%91BIOS%E7%83%AD%E9%94%AEU%E7%9B%98%E5%90%AF%E5%8A%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%A1%A8/">电脑BIOS热键U盘启动快捷键表</a>
          </li>
        
          <li>
            <a href="">MySQL优化技巧</a>
          </li>
        
          <li>
            <a href="../SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">SQL学习笔记</a>
          </li>
        
          <li>
            <a href="../../26/VSCode%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BAShell%E9%9B%86%E6%88%90%E6%97%A0%E6%B3%95%E6%BF%80%E6%B4%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">VSCode终端提示Shell集成无法激活的解决方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
      <div class="widget-box">
    <h3 class="widget-title">友链</h3>
    <div class="widget">
      
        <!-- <a style="display: block;" href="../../../../https:/xiaoyan94.github.io/" title target='_blank' -->
        <a style="display: block;" href="https://xiaoyan94.github.io/" title target='_blank'
        >Github Pages</a>
      
        <!-- <a style="display: block;" href="../../../../https:/xy94.gitee.io/" title target='_blank' -->
        <a style="display: block;" href="https://xy94.gitee.io/" title target='_blank'
        >Gitee Pages</a>
      
    </div>
  </div>

  
 
  
</aside>
      </div>
      <footer id="footer">
  <div class="foot-box global-width center">
    &copy; 2022 许嵩老公 &nbsp;&nbsp;
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    &nbsp;|&nbsp;主题 <a href="https://github.com/yiluyanxia/hexo-theme-antiquity" target="_blank" rel="noopener">antiquity</a>
    <br>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">不蒜子告之   阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
    
  </div>
  
  <!--引入文字点击特效-->
  <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
  
<script src="../../../../js/dianji.js"></script>

</footer>

<!--添加回到顶部按钮-->
<style>
/* 小猫置顶 */
/* 自定义回到顶部样式 */
.cd-top {
  position: fixed;
  right: 25px;
  top: -900px;
  z-index: 99;
  width: 70px;
  height: 900px;
  /* background: url(https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/images/scroll.png) no-repeat center; */
  background: url(/images/scroll.png) no-repeat center;
  background-size: contain;
  -webkit-transition: all .5s ease-in-out;
  transition: all .5s ease-in-out;
  /* cursor: url(https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.9/img/Sakura/cursor/No_Disponible.cur), auto; */
  cursor: url(/images/cursor/No_Disponible.cur), auto;
  opacity: 1
}

.cd-top.cd-is-visible {
  opacity: 1;
  top: -326px
}

.cd-top.cd-fade-out {
  opacity: 1
}

.cd-top:hover {
  opacity: 1
}

.cd-top span {
  display: none;
  color: #000;
  position: absolute;
  bottom: 0;
  height: 20px;
  width: 50px;
  text-align: center
}

@media screen and (max-width:860px) {
  .cd-top {
      display: none;
      height: 60px;
      width: 50px
  }
  .cd-top span {
      height: 10px;
      width: 50px
  }
}

#moblieGoTop {
  display: none;
  position: fixed;
  bottom: 10px;
  right: 10px;
  z-index: 99;
  border: 0;
  outline: 0;
  background-color: #fff;
  color: #404040;
  cursor: pointer;
  padding: 15px;
  border-radius: 10px;
  border-radius: 12px;
  box-shadow: 0 0 2px 0 rgba(0, 0, 0, .12), 0 2px 2px 0 rgba(0, 0, 0, .24);
  transition: box-shadow .2s ease
}
#moblieGoTop:hover {
  background-color: #fff;
  opacity: .8
}
.changeSkin-gear {
  position: fixed;
  bottom: 0;
  left: auto;
  right: 5px;
  width: auto;
  height: auto;
  z-index: 99;
  white-space: nowrap;
  padding: 10px 10px;
  cursor: pointer;
  border-radius: 10px 10px 0 0
}
</style>

<!-- 添加小猫置顶 -->
<a class="cd-top faa-float animated cd-is-visible cd-fade-out" style="top: -500px;"></a>
<button id="moblieGoTop" title="Go to top" style="display: none;font-size: xx-large;"><i class="fa fa-chevron-up" aria-hidden="true"></i>🔝</button>

<!-- <div class="scroll "> <i class="fa fa-arrow-up" style="margin-left: 4px;"></i>
Top⬆️
<span class="scrollpercent" style="margin-left: -2px;"></span>
<span style="margin-right: 4px; margin-left: -4px;">%</span>
</div> -->

<!-- https://www.huangpinke.com/2018/08/24/add-back-to-top-button.html -->
      <script src="https://code.jquery.com/jquery-2.0.3.min.js"></script>
<script>
if (!window.jQuery) {
var script = document.createElement('script');
script.src = "/js/jquery-2.0.3.min.js";
document.body.write(script);
}
</script>

  
<link rel="stylesheet" href="../../../../fancybox/jquery.fancybox.css">

  
<script src="../../../../fancybox/jquery.fancybox.pack.js"></script>




<script src="../../../../js/script.js"></script>




<script>
  (function(){
      var bp = document.createElement('script');
      bp.src = '//push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>

<!-- mermaid图 -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="../../../../index.html" class="mobile-nav-link">首页</a>
  
    <a href="../../../../archives" class="mobile-nav-link">归档</a>
  
    <a href="../../../../quick-notes" class="mobile-nav-link">小抄</a>
  
    <a href="../../../../about" class="mobile-nav-link">关于</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>

</html>